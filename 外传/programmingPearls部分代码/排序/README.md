# 《编程珠玑》部分代码

## [insertSort.cpp]()

基本思想是保证数组前面的排列是有序的，未排序的已排序的部分的后面向前比较，互换。

## [quickSort.cpp]() 

基本思想是找一个标准值（如list[0]），从后向前找比标准值小的值，从前向后找比标准值大的值，交换；这样标准值左面都小于标准值，右面都大于标准值；递归排序，即可得到已排序数组。

* 函数 quicKSort1() 直接对整个数组排序；
* quickSort2() 在 1 的基础上增加了随机选取比较值的步骤，减少了对已排序的数组需要从头遍历到尾的可能；
* quickSort3() 在 2 的基础上，对长度较短的数组直接采用插入排序的方法，因为在待排序的内容较少时，插入排序效率更高。这里写了个新的 insertSort 方法。


## [sampling.cpp]()

题目：从n个数字中选择m个不重复数字。

主要思路：
1. 随机生成一个数字，将这个数组插入到目的数组中，如果这个数字重复，则继续生成；
2. 创建一个包含n个数字的数组，对前m个数字随机交换；
3. 实际测试在 m=5000000, n=1000000000，前者需要7s左右，后者需要3s左右；
4. 在visual studio 2017 上跑的时候，n=1000000000 时new 失败的，原因是32位地址寻址空间为4G，最多申请4G内存，int占4字节，4*1000000000/1024/1024/1024 = 3.7G，系统已经用了6个多G，不可能分配这么多内存。将 vs 的模式修改为 x64 模式即可。

## [desc.cpp]()

题目：从 n 个数字中随机选出 m 个数字，并顺序/逆序输出；

思路：第一个数字被选中的概率是 m/n，用代码表示是 bigrand() % n < m。如果第 1 个数字被选中，那么剩余可选的的数字总数为(n - 1),需要选中的数字总数为(m - 1)，递归可解决。

* randomSelect(int, int) 逆序输出，randomSelectAsc(int, int)顺序输出。不同是输出（cout）位置不同。这个类似二叉树前序、中序、后序遍历。

## [choiceOneLine.cpp]()

题目：从未知行数的文件中随机选取一行输出。

思路：这个题目挺有意思的，考虑的也是对概率的理解。第m行按照 1/m 的概率选择时，最终被选中的概率为 第m行被选中的概率 * 后续行不被选中的概率，即： __1/m * m/(m+1) * (m+1)/(m+2) * (n-1)/n = 1/n__。读文件比较方便，直接就用 python 表示了。

* 1/m 概率这里直接调用python的 random 库，用 random.randint(1, index) % (index + 1) == 1 来表示了。
* 1/m 用一贯用的 bigrand() 方法表示是
	~~~cpp
	bigrand() % (index + 1) < 1; // == 1也可以
	~~~

## [heapSort.cpp]()
对长度为n的数组进行堆排序，精髓在于，每个节点的父节点都比子节点大，这样最顶层的根节点最大。交换根节点和第n-1个节点，最大的值就被排到了数组末尾，对[0-(n-1)]排序，选出最大的节点，交换根节点和n-2节点位置。依次进行即可排序。